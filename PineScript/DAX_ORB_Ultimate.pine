//@version=6
indicator("DAX ORB Ultimate - ALGO Suite", overlay=true, max_labels_count=200, max_lines_count=100)

// ═══════════════════════════════════════════════════════════════════════════════
// DAX OPENING RANGE BREAKOUT - ULTIMATE EDITION
// Real-time ORB building | Multi-timeframe support | Key levels with bias
// Works on ANY timeframe - uses M1 data for ORB construction
// ═══════════════════════════════════════════════════════════════════════════════

// ════════════════════════ INPUTS ════════════════════════

orb_start_h = input.int(7, "Start Hour (UTC)", minval=0, maxval=23, group="ORB Settings")
orb_start_m = input.int(40, "Start Minute", minval=0, maxval=59, group="ORB Settings")
orb_end_h = input.int(8, "End Hour (UTC)", minval=0, maxval=23, group="ORB Settings")
orb_end_m = input.int(0, "End Minute", minval=0, maxval=59, group="ORB Settings")
exclude_wicks = input.bool(true, "Exclude Wicks", group="ORB Settings")
close_hour = input.int(16, "Market Close Hour", minval=0, maxval=23, group="ORB Settings")

use_tf = input.bool(true, "1. Trend Following", group="Strategies")
use_mr = input.bool(true, "2. Mean Reversion", group="Strategies")
use_sa = input.bool(true, "3. Statistical Arb", group="Strategies")
use_mm = input.bool(true, "4. Market Making", group="Strategies")
use_ba = input.bool(true, "5. Basis Arb", group="Strategies")

use_ema = input.bool(true, "EMA Filter", group="Technical Filters")
use_rsi = input.bool(true, "RSI Filter", group="Technical Filters")
use_macd = input.bool(true, "MACD Filter", group="Technical Filters")
use_vol = input.bool(true, "Volume Filter", group="Technical Filters")
use_bb = input.bool(true, "Bollinger Filter", group="Technical Filters")

// SL/TP functionality removed - pure signal generation only

show_dash = input.bool(true, "Show Dashboard", group="Display")
show_lines = input.bool(true, "Show Lines", group="Display")
show_levels = input.bool(true, "Show Key Levels", group="Display")

// ════════════════════════ FUNCTIONS ════════════════════════

is_orb_period(_h, _m) =>
    start = orb_start_h * 60 + orb_start_m
    end = orb_end_h * 60 + orb_end_m
    curr = _h * 60 + _m
    curr >= start and curr < end

orb_ended(_h, _m) =>
    end = orb_end_h * 60 + orb_end_m
    curr = _h * 60 + _m
    curr == end

is_market_open() =>
    h = hour(time)
    h >= orb_start_h and h <= close_hour

// ════════════════════════ DATA GATHERING (M1) ════════════════════════

// Get M1 data for ORB construction (ORB calculated from 1-minute bars, visible on ALL timeframes)
[m1_time, m1_open, m1_high, m1_low, m1_close] = request.security(syminfo.tickerid, "1", [time, open, high, low, close], barmerge.gaps_off, barmerge.lookahead_off)

// Daily data
d_high = request.security(syminfo.tickerid, "D", high, barmerge.gaps_off, barmerge.lookahead_on)
d_low = request.security(syminfo.tickerid, "D", low, barmerge.gaps_off, barmerge.lookahead_on)
d_open = request.security(syminfo.tickerid, "D", open, barmerge.gaps_off, barmerge.lookahead_on)

// Current day high/low (intraday)
var float today_high = na
var float today_low = na
var float prev_day_high = na
var float prev_day_low = na
var float yest_size = 0

if ta.change(time("D")) != 0
    prev_day_high := d_high[1]
    prev_day_low := d_low[1]
    yest_size := d_high[1] - d_low[1]
    today_high := high
    today_low := low
else
    today_high := math.max(na(today_high) ? high : today_high, high)
    today_low := math.min(na(today_low) ? low : today_low, low)

// ════════════════════════ ORB CONSTRUCTION (REAL-TIME) ════════════════════════

var float orb_h = na
var float orb_l = na
var bool orb_ready = false
var float orb_building_h = na
var float orb_building_l = na
var bool is_building = false

// Get M1 bar time components
m1_hour = hour(m1_time)
m1_minute = minute(m1_time)

// Reset daily
if ta.change(time("D")) != 0
    orb_h := na
    orb_l := na
    orb_ready := false
    orb_building_h := na
    orb_building_l := na
    is_building := false

// Build ORB using M1 data
if is_orb_period(m1_hour, m1_minute) and not orb_ready
    is_building := true
    val_h = exclude_wicks ? m1_close : m1_high
    val_l = exclude_wicks ? m1_close : m1_low

    if na(orb_building_h)
        orb_building_h := val_h
        orb_building_l := val_l
    else
        orb_building_h := math.max(orb_building_h, val_h)
        orb_building_l := math.min(orb_building_l, val_l)

// FIX #1: Set is_building to false when NOT in ORB period anymore
if not is_orb_period(m1_hour, m1_minute) and is_building and not orb_ready
    is_building := false

// Finalize ORB when period ends
if orb_ended(m1_hour, m1_minute) and not orb_ready
    orb_h := orb_building_h
    orb_l := orb_building_l
    orb_ready := true
    is_building := false

// Display building values in real-time
current_orb_h = is_building ? orb_building_h : orb_h
current_orb_l = is_building ? orb_building_l : orb_l

// ════════════════════════ INDICATORS ════════════════════════

ema9 = ta.ema(close, 9)
ema21 = ta.ema(close, 21)
ema50 = ta.ema(close, 50)
rsi = ta.rsi(close, 14)
[macd, sig, _] = ta.macd(close, 12, 26, 9)
[bb_mid, bb_up, bb_low] = ta.bb(close, 20, 2)
atr = ta.atr(14)
vol_ma = ta.sma(volume, 20)

// ════════════════════════ STRATEGY SIGNALS ════════════════════════

// 1. Trend Following
tf_short = ta.sma(close, 10)
tf_long = ta.sma(close, 30)
tf_bull = tf_short > tf_long
tf_bear = tf_short < tf_long

// 2. Mean Reversion
mr_mean = ta.sma(close, 20)
mr_dev = (close - mr_mean) / mr_mean * 100
mr_bull = mr_dev <= -0.5
mr_bear = mr_dev >= 0.5

// 3. Statistical Arb
sa_mean = ta.sma(close, 120)
sa_std = ta.stdev(close, 120)
sa_z = sa_std > 0 ? (close - sa_mean) / sa_std : 0
var string sa_st = "flat"
if sa_st == "flat"
    if sa_z <= -2.0
        sa_st := "long"
    else if sa_z >= 2.0
        sa_st := "short"
else if math.abs(sa_z) <= 0.5 or math.abs(sa_z) >= 4.0
    sa_st := "flat"
sa_bull = sa_st == "long"
sa_bear = sa_st == "short"

// 4. Market Making
mm_spread = (high - low) / close * 100
mm_mid = (high + low) / 2
mm_bull = close < mm_mid and mm_spread >= 0.5
mm_bear = close > mm_mid and mm_spread >= 0.5

// 5. Basis Arb
ba_fair = ta.sma(close, 50)
ba_bps = ba_fair != 0 ? (close - ba_fair) / ba_fair * 10000 : 0
ba_bull = ba_bps <= -8.0
ba_bear = ba_bps >= 8.0

// Vote counting
bull_v = 0
bear_v = 0
if use_tf
    bull_v := bull_v + (tf_bull ? 1 : 0)
    bear_v := bear_v + (tf_bear ? 1 : 0)
if use_mr
    bull_v := bull_v + (mr_bull ? 1 : 0)
    bear_v := bear_v + (mr_bear ? 1 : 0)
if use_sa
    bull_v := bull_v + (sa_bull ? 1 : 0)
    bear_v := bear_v + (sa_bear ? 1 : 0)
if use_mm
    bull_v := bull_v + (mm_bull ? 1 : 0)
    bear_v := bear_v + (mm_bear ? 1 : 0)
if use_ba
    bull_v := bull_v + (ba_bull ? 1 : 0)
    bear_v := bear_v + (ba_bear ? 1 : 0)

// Technical filters - Simplified scoring system
ema_ok_b = not use_ema or (ema9 > ema21 and close > ema50)
ema_ok_s = not use_ema or (ema9 < ema21 and close < ema50)
rsi_ok_b = not use_rsi or (rsi > 40 and rsi < 80)  // More lenient
rsi_ok_s = not use_rsi or (rsi < 60 and rsi > 20)  // More lenient
macd_ok_b = not use_macd or macd > sig
macd_ok_s = not use_macd or macd < sig
vol_ok = not use_vol or volume > vol_ma * 1.2  // More lenient
bb_ok_b = not use_bb or close > bb_mid
bb_ok_s = not use_bb or close < bb_mid

// Technical score (need at least 2 out of 5 filters)
tech_score_b = (ema_ok_b ? 1 : 0) + (rsi_ok_b ? 1 : 0) + (macd_ok_b ? 1 : 0) + (bb_ok_b ? 1 : 0) + (vol_ok ? 1 : 0)
tech_score_s = (ema_ok_s ? 1 : 0) + (rsi_ok_s ? 1 : 0) + (macd_ok_s ? 1 : 0) + (bb_ok_s ? 1 : 0) + (vol_ok ? 1 : 0)
tech_bull = tech_score_b >= 2
tech_bear = tech_score_s >= 2

// Breakout - SIMPLIFIED (just need close above/below ORB)
brk_bull = orb_ready and close > current_orb_h
brk_bear = orb_ready and close < current_orb_l

// Consensus - At least 2 strategies agree (not majority)
total_st = (use_tf ? 1 : 0) + (use_mr ? 1 : 0) + (use_sa ? 1 : 0) + (use_mm ? 1 : 0) + (use_ba ? 1 : 0)
consensus_b = bull_v >= 2
consensus_s = bear_v >= 2

// Final signals - MUCH MORE LENIENT
daily_ok = yest_size >= 50  // Reduced from 100
buy = brk_bull and consensus_b and tech_bull and is_market_open()
sell = brk_bear and consensus_s and tech_bear and is_market_open()

// ════════════════════════ CLEAN SIGNALS ════════════════════════

// Simple signal generation without SL/TP complexity
buy_final = buy
sell_final = sell

// Trailing stops removed - pure signal indicator

// ════════════════════════ ANALYTICS ════════════════════════

prob_strat = total_st > 0 ? math.max(bull_v, bear_v) / total_st * 100 : 50
prob_tech = (tech_bull or tech_bear) ? 75 : 35
prob_vol = vol_ok ? 85 : 50
prob_daily = daily_ok ? 85 : 30
prob_orb = orb_ready ? 80 : 20
probability = prob_strat * 0.3 + prob_tech * 0.25 + prob_vol * 0.15 + prob_daily * 0.15 + prob_orb * 0.15

dir_score = 0
dir_score := dir_score + (ema9 > ema21 ? 2 : -2)
dir_score := dir_score + (tf_bull ? 2 : -2)
dir_score := dir_score + (macd > sig ? 1 : -1)
dir_score := dir_score + (rsi > 50 ? 1 : -1)
direction = dir_score >= 2 ? "STRONG BULL" : (dir_score > 0 ? "BULL" : (dir_score <= -2 ? "STRONG BEAR" : (dir_score < 0 ? "BEAR" : "NEUTRAL")))

clean_trend = math.abs(ema9 - ema21) / close * 100
clean_noise = atr / close * 100
clean_struct = close > ema9 and close > ema21 and close > ema50 or close < ema9 and close < ema21 and close < ema50
clean_score = (clean_trend > 0.5 ? 30 : 10) + (clean_noise < 1.5 ? 30 : 10) + (clean_struct ? 40 : 10)
quality = clean_score >= 70 ? "CLEAN" : (clean_score >= 50 ? "GOOD" : (clean_score >= 30 ? "OK" : "CHOPPY"))

mom = ta.mom(close, 10)
mom_str = math.abs(mom) / close * 100
vol_rat = atr / ta.sma(atr, 20)
movement = buy_final or sell_final ? (mom_str > 0.8 and vol_rat > 1.3 ? "STRONG" : (mom_str > 0.5 ? "MODERATE" : "GRADUAL")) : "WAIT"

ok_score = (daily_ok ? 25 : 0) + (orb_ready ? 25 : 0) + (is_market_open() ? 20 : 0) + (clean_score >= 50 ? 20 : 5) + (probability >= 60 ? 10 : 0)
ok_trade = ok_score >= 65

// ════════════════════════ KEY LEVELS WITH BIAS ════════════════════════

// Calculate potential reaction levels with directional bias
var float[] key_levels = array.new_float(0)
var string[] key_bias = array.new_string(0)

if barstate.islast and show_levels
    array.clear(key_levels)
    array.clear(key_bias)

    // Add levels with bias
    if not na(current_orb_h)
        array.push(key_levels, current_orb_h)
        array.push(key_bias, consensus_b ? "BULL BREAK" : "RESISTANCE")

    if not na(current_orb_l)
        array.push(key_levels, current_orb_l)
        array.push(key_bias, consensus_s ? "BEAR BREAK" : "SUPPORT")

    if not na(prev_day_high)
        array.push(key_levels, prev_day_high)
        bias_pdh = close > prev_day_high ? "BULLISH" : (close < prev_day_high and close > prev_day_high * 0.995 ? "WATCH" : "RESIST")
        array.push(key_bias, bias_pdh)

    if not na(prev_day_low)
        array.push(key_levels, prev_day_low)
        bias_pdl = close < prev_day_low ? "BEARISH" : (close > prev_day_low and close < prev_day_low * 1.005 ? "WATCH" : "SUPPORT")
        array.push(key_bias, bias_pdl)

    if not na(today_high)
        array.push(key_levels, today_high)
        array.push(key_bias, "TODAY HIGH")

    if not na(today_low)
        array.push(key_levels, today_low)
        array.push(key_bias, "TODAY LOW")

    // Add EMA50 as dynamic level
    array.push(key_levels, ema50)
    ema_bias = close > ema50 ? "BULL SUPPORT" : "BEAR RESIST"
    array.push(key_bias, ema_bias)

// ════════════════════════ VISUALS ════════════════════════

// Previous day lines
plot(show_lines ? prev_day_high : na, "Prev Day H", color.new(color.yellow, 0), 1, plot.style_line)
plot(show_lines ? prev_day_low : na, "Prev Day L", color.new(color.orange, 0), 1, plot.style_line)

// Current day high/low
plot(show_lines ? today_high : na, "Today High", color.new(color.lime, 40), 2, plot.style_circles)
plot(show_lines ? today_low : na, "Today Low", color.new(color.red, 40), 2, plot.style_circles)

// ORB lines (show building values in real-time with separate plots)
// Building phase - circles (orange during building)
plot(show_lines and is_building and not na(current_orb_h) ? current_orb_h : na, "ORB High Building", color.new(color.orange, 30), 3, plot.style_circles)
plot(show_lines and is_building and not na(current_orb_l) ? current_orb_l : na, "ORB Low Building", color.new(color.orange, 30), 3, plot.style_circles)

// Ready phase - ULTRA BRIGHT solid lines
plot(show_lines and not is_building and not na(current_orb_h) ? current_orb_h : na, "ORB High Ready", color.new(color.aqua, 0), 4, plot.style_line)
plot(show_lines and not is_building and not na(current_orb_l) ? current_orb_l : na, "ORB Low Ready", color.new(color.aqua, 0), 4, plot.style_line)

// ORB zone fill
p1 = plot(not na(current_orb_h) ? current_orb_h : na, display=display.none)
p2 = plot(not na(current_orb_l) ? current_orb_l : na, display=display.none)
fill_color = is_building ? color.new(color.blue, 93) : color.new(color.blue, 88)
fill(p1, p2, fill_color, title="ORB Zone")

// FIX #2: ORB box with far future right edge - guaranteed extension
var box orb_box = na
var bool orb_box_drawn = false

// Reset box drawn flag on new day
if ta.change(time("D")) != 0
    orb_box_drawn := false

// Draw box when ORB becomes ready, use far future bar for reliable extension
if orb_ready and not orb_box_drawn and not na(orb_h) and not na(orb_l) and show_lines
    if not na(orb_box)
        box.delete(orb_box)

    // Ultra clear rectangle with thick bright borders
    box_color = color.new(color.aqua, 85)  // Bright aqua fill
    border_color = color.new(color.aqua, 0)  // Solid bright aqua border

    // Create box with far future right edge - this guarantees extension
    // Use bar_index + 500 to extend well into the future
    orb_box := box.new(bar_index - 10, orb_h, bar_index + 500, orb_l,
                       border_color=border_color,
                       border_width=3,  // Thicker border
                       bgcolor=box_color,
                       text="ORB ZONE (M1 Data)",
                       text_size=size.normal,  // Larger text
                       text_color=color.new(color.aqua, 0))  // Bright text
    orb_box_drawn := true

// FIX #7: Let Pine Script handle box extension automatically
// No manual updates needed - extend=extend.right handles it

// EMAs
plot(use_ema ? ema9 : na, "EMA9", color.new(color.blue, 20), 1)
plot(use_ema ? ema21 : na, "EMA21", color.new(color.orange, 20), 1)
plot(use_ema ? ema50 : na, "EMA50", color.new(color.purple, 30), 2)

// Signals
plotshape(buy_final, "BUY", shape.triangleup, location.belowbar, color.new(color.lime, 0), size=size.small, text="BUY")
plotshape(sell_final, "SELL", shape.triangledown, location.abovebar, color.new(color.red, 0), size=size.small, text="SELL")

// All SL/TP visuals removed for clean signals-only display

// SL/TP lines and labels removed for clean display

// FIX #4: Key level labels - Track and delete old labels to prevent duplication
var label[] key_level_labels = array.new_label(0)

// Delete all old key level labels
if array.size(key_level_labels) > 0
    for i = 0 to array.size(key_level_labels) - 1
        label.delete(array.get(key_level_labels, i))
    array.clear(key_level_labels)

// Create key level labels only on last bar
if barstate.islast and show_levels and array.size(key_levels) > 0
    for i = 0 to array.size(key_levels) - 1
        lvl = array.get(key_levels, i)
        bias = array.get(key_bias, i)

        // Color based on bias
        lbl_color = str.contains(bias, "BULL") ? color.new(color.green, 70) : (str.contains(bias, "BEAR") ? color.new(color.red, 70) : (str.contains(bias, "SUPPORT") ? color.new(color.blue, 70) : (str.contains(bias, "RESIST") ? color.new(color.orange, 70) : color.new(color.gray, 70))))

        txt_color = str.contains(bias, "BULL") ? color.green : (str.contains(bias, "BEAR") ? color.red : (str.contains(bias, "SUPPORT") ? color.blue : (str.contains(bias, "RESIST") ? color.orange : color.gray)))

        new_lbl = label.new(bar_index + 2, lvl, str.tostring(lvl, "#.##") + "\n" + bias, style=label.style_label_left, color=lbl_color, textcolor=txt_color, size=size.tiny, textalign=text.align_left)
        array.push(key_level_labels, new_lbl)

// FIX #5: Compact chart info labels - Track and delete to prevent duplication
var label prob_label = na
var label dir_label = na

if barstate.islast and show_lines
    // Delete old labels
    if not na(prob_label)
        label.delete(prob_label)
    if not na(dir_label)
        label.delete(dir_label)

    // Create new labels
    prob_c = probability >= 70 ? color.green : (probability >= 50 ? color.yellow : color.red)
    prob_label := label.new(bar_index, high + atr * 1.2, str.tostring(probability, "#") + "%", style=label.style_none, textcolor=prob_c, size=size.small)

    dir_c = str.contains(direction, "BULL") ? color.green : (str.contains(direction, "BEAR") ? color.red : color.gray)
    dir_label := label.new(bar_index, high + atr * 2, direction, style=label.style_none, textcolor=dir_c, size=size.tiny)

// ════════════════════════ DASHBOARD ════════════════════════

var table dash = table.new(position.top_right, 2, 30, bgcolor=color.new(color.black, 5), border_width=1, border_color=color.new(color.gray, 60))

if barstate.islast and show_dash
    r = 0

    // Header
    table.cell(dash, 0, r, "DAX ORB ULTIMATE", text_color=color.white, bgcolor=color.new(color.blue, 30), text_size=size.small)
    table.cell(dash, 1, r, timeframe.period, text_color=color.yellow, bgcolor=color.new(color.blue, 30), text_size=size.tiny)

    // Current Day
    r += 1
    table.cell(dash, 0, r, "TODAY H/L", text_color=color.aqua, text_size=size.tiny)
    table.cell(dash, 1, r, "", text_color=color.white)

    r += 1
    table.cell(dash, 0, r, "High", text_color=color.gray, text_size=size.tiny)
    table.cell(dash, 1, r, str.tostring(today_high, "#.##"), text_color=color.lime, text_size=size.tiny)

    r += 1
    table.cell(dash, 0, r, "Low", text_color=color.gray, text_size=size.tiny)
    table.cell(dash, 1, r, str.tostring(today_low, "#.##"), text_color=color.red, text_size=size.tiny)

    r += 1
    table.cell(dash, 0, r, "Range", text_color=color.gray, text_size=size.tiny)
    today_range = today_high - today_low
    table.cell(dash, 1, r, str.tostring(today_range, "#") + "p", text_color=color.aqua, text_size=size.tiny)

    // Previous Day
    r += 1
    table.cell(dash, 0, r, "PREV H/L", text_color=color.aqua, text_size=size.tiny)
    table.cell(dash, 1, r, str.tostring(yest_size, "#") + "p", text_color=daily_ok ? color.lime : color.red, text_size=size.tiny)

    // ORB Status with real-time values (M1 Data)
    r += 1
    table.cell(dash, 0, r, "ORB M1 Data", text_color=color.aqua, text_size=size.tiny)
    orb_status = is_building ? "BUILDING" : (orb_ready ? "READY" : "WAIT")
    orb_clr = is_building ? color.orange : (orb_ready ? color.lime : color.gray)
    table.cell(dash, 1, r, orb_status, text_color=orb_clr, text_size=size.tiny)

    r += 1
    table.cell(dash, 0, r, "High", text_color=color.gray, text_size=size.tiny)
    orb_h_txt = not na(current_orb_h) ? str.tostring(current_orb_h, "#.##") : "---"
    table.cell(dash, 1, r, orb_h_txt, text_color=is_building ? color.orange : color.green, text_size=size.tiny)

    r += 1
    table.cell(dash, 0, r, "Low", text_color=color.gray, text_size=size.tiny)
    orb_l_txt = not na(current_orb_l) ? str.tostring(current_orb_l, "#.##") : "---"
    table.cell(dash, 1, r, orb_l_txt, text_color=is_building ? color.orange : color.red, text_size=size.tiny)

    r += 1
    table.cell(dash, 0, r, "Size", text_color=color.gray, text_size=size.tiny)
    orb_size = not na(current_orb_h) and not na(current_orb_l) ? current_orb_h - current_orb_l : 0
    table.cell(dash, 1, r, str.tostring(orb_size, "#") + "p", text_color=color.yellow, text_size=size.tiny)

    // Strategies
    r += 1
    table.cell(dash, 0, r, "STRATEGIES", text_color=color.aqua, text_size=size.tiny)
    table.cell(dash, 1, r, str.tostring(bull_v) + "B " + str.tostring(bear_v) + "S", text_color=color.yellow, text_size=size.tiny)

    // Analytics
    r += 1
    table.cell(dash, 0, r, "PROBABILITY", text_color=color.white, bgcolor=color.new(color.purple, 70), text_size=size.small)
    prob_c = probability >= 70 ? color.lime : (probability >= 50 ? color.yellow : color.red)
    table.cell(dash, 1, r, str.tostring(probability, "#") + "%", text_color=prob_c, bgcolor=color.new(color.purple, 70), text_size=size.small)

    r += 1
    table.cell(dash, 0, r, "Direction", text_color=color.gray, text_size=size.tiny)
    dir_c = str.contains(direction, "BULL") ? color.lime : (str.contains(direction, "BEAR") ? color.red : color.gray)
    table.cell(dash, 1, r, direction, text_color=dir_c, text_size=size.tiny)

    r += 1
    table.cell(dash, 0, r, "Chart", text_color=color.gray, text_size=size.tiny)
    qual_c = quality == "CLEAN" ? color.lime : (quality == "GOOD" ? color.green : (quality == "OK" ? color.yellow : color.red))
    table.cell(dash, 1, r, quality, text_color=qual_c, text_size=size.tiny)

    r += 1
    table.cell(dash, 0, r, "OK Trade?", text_color=color.gray, text_size=size.tiny)
    table.cell(dash, 1, r, ok_trade ? "YES" : "NO", text_color=ok_trade ? color.lime : color.red, text_size=size.tiny)

    // Position tracking removed - signals-only indicator

    // Signal
    r += 1
    table.cell(dash, 0, r, "SIGNAL", text_color=color.white, bgcolor=color.new(color.green, 50), text_size=size.small)
    sig_txt = buy_final ? "BUY NOW" : (sell_final ? "SELL NOW" : "WAIT")
    sig_c = buy_final ? color.lime : (sell_final ? color.red : color.gray)
    table.cell(dash, 1, r, sig_txt, text_color=sig_c, bgcolor=color.new(color.green, 50), text_size=size.small)

    // All SL/TP levels removed - clean signals-only dashboard

// ════════════════════════ ALERTS ════════════════════════

alertcondition(buy_final, "BUY Signal", "DAX ORB BUY")
alertcondition(sell_final, "SELL Signal", "DAX ORB SELL")
alertcondition(orb_ready and not orb_ready[1], "ORB Ready", "DAX ORB READY")
alertcondition(is_building and not is_building[1], "ORB Building", "DAX ORB BUILDING")
alertcondition(ok_trade and not ok_trade[1], "Ready to Trade", "DAX OK")
